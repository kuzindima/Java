25.10.14
[Следующая в 10.10 во вторник]
--ТЕРНАРНЫЕ ОПЕРАТОРЫ
вопрос? действие1:действие2;
вместо if/else
--Оператор continue
--Char & String
String x="...";
String x=new String();
char[] Chars;
String x=new String(Chars);
int x=(int) 'a'; \код буквы а
char[] array2=x.toCharArray();

\\
public static int compare(String x1,String x2){

 return result;
 }
 \\
 для проверки равноти строк лучше использовать equals
 x1.equals(x2);
 --substring
 String x="home nkjfh";
 String x:=x.subString(0,3);



28.10.14
indexOf("три");\\индекс собсна
replace("три","четыре");\\заменяет слова или буквы
split(' ');//разделяет на массив строк
String x="Hello";
boolean to x=x.contains

1.11.2014

toLowerCase()   приводит к нижнему регистру
toUpperCase()   приводит к верхнему регистру если a -> A
trim()  убирает пробелы в начале и конце строки
\\Экранирование
он сказал :"Привет друг".
String x="он сказал :\"Привет друг\"."
\\
дз доделать с учетом уперкэйсс ловеркэйс и трип с методом компарэ
2. реализовать словарь
2 массива из слов original and translate
двоичный поиск по тексту
пример

String[] original={"Привет","Как дела?","Спишь"}
String[] translate={"Hello","How are you","Do you sleep?"}

1.Формируем массив
2.Сортируем два массива,так чтобы не потерялись связки(индексы)
3.Реализуем поиск(двоичный) с индекса слова
исползовать compare с lowercase and trim


P18,P19 to github
+доделать прошлую дз+сделать дз с фотки+переводчик все к пятнице

08.11.14
a[i]>a[i+1]==false
a[i]<a[i+1]
1 and 2 equals

дз(P23,24)
словарь
бинарный поисск по словам
1.метод который возвращает 2 массива..сортировка внутри
2.метод получения перевода.. String translate(String x)
3.метод поиска позиции..позиция исходного слова в словаре..вводим слово возвращает номер
4.метод получения другого перевода
прочитать про параметральные перегрузки
использовать вместо 2 одномерных 1 двумерный
12.11.14
P24
P25
P26 до чт
15.11.14
Рекурсия
P27
P28 fibonacci
18.11.14
 дз сделать pow с головной рекурсией
 кл  P29/30/31

25.11.14

reverse 1 variant 1 exp\
public static int[] reverse(int[] arr){
   int buff=0;
    for(i=0;i<arr.length;i++){
       buf=arr[i];
       arr[i]=arr[(arr.length-1)-i];
       arr[(arr.length-1)-i]=buf;
    }
    return arr;
   }
P34 CW
P35 CW
Обьктно ориентированное программирование
ООП
29.11.14
public class ConsoleWriter{
public void write(String text){
System.out.println(text);
}
}
класс обьявляется с помощью 4 модификаторов доступа : public, protected, private, package protected
protected - доступ имеет только наследник
private - только в main'е
class ConsoleWriter{
private int model=15;
private String brand="Yoga";
public int sum()
}
to git
p38
calc
все классы наследуются от класса object
у него есть методы hash code(),equals(),to String()
обьявляя класс можно оббявить его родителей напр clss Dog extends Animal
интерфейс implements содержит название метода описывает только поведение
2.12.14
Принципы ООП
Инкапсуляция
 public
 private
 protected
Полиморфизм
Animal x=new Dog();
dog будет имиеть поля только animal
или
Animal[] arr=new Animal[5];
arr.move();
P40


9.12.14
Принцип перестановки Барбары Рисков!!! выучить!!!
Интерфейс
поле то что описывает класс
Main
Furniture
Chair
Animal
Dog
Cat
Soundable
Movable
Параметрический полиморфизм
public interface movable{
int move();
}
Паттерное проектирование
Фабрика обьектов
Animal x=fabrica.getHorse();
class fabrica
method getHorse
etc
object getHorse
getHorse (){x.sound()}
read about pattern projective


